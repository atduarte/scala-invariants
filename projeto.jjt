options
{
    LOOKAHEAD=1;
    STATIC=false;
}

PARSER_BEGIN(InvariantParser)
/*Coisas p/ adicionar depois de compilar:
 SimpleNode:

  Vector<Integer> operators;
  String numVar;
  

*/

package invariant.invariantEvaluator.Parser;
import java.util.HashMap;
import java.util.Vector;
import java.lang.Integer;
import java.lang.String;

public class InvariantParser
{
	Vector<String> vars;
	InvariantParserConstants constants;
	SimpleNode getTree(String exrp){
		return Inv_exp();
	}

}

PARSER_END(InvariantParser)


SKIP :
{
	" " |  "\r" | "\t"
}

TOKEN:
{
          <VAR		 :"$"(["0"-"9"])+ >
      	| <NUM		 :(["0"-"9"])*(".")?(["0"-"9"])+ >
		| <OR		 :"||" >
		| <AND		 : "&&" >
		| <REC_BRAC_O: "["  >
		| <REC_BRAC_C: "]"  >
		| <PAR_OPEN  : "("  >
		| <PAR_CLOSE : ")"  >
		| <PAR_SETO  : "{"  >
		| <PAR_SETC  : "}"  >
		| <COMMA     : ","  >
		| <EQUAL 	 : "="  >
		| <NOTEQUAL  : "!=" >      
		| <INF       : "@inf">
		| <OP_SUM    :  "+" >
		| <OP_DIFF   :  "-" >
		| <OP_MUL    :  "*" >
		| <OP_DIV    :  "/" >

}

SimpleNode Inv_exp():{}{
	OrExpr() "\n"
	{return jjtThis;}
}
void OrExpr():{}{
	AndExpr() ( <OR> AndExpr() )* 
}
void AndExpr():{}{
	atomInv() ( <AND> atomInv() )*
}
void atomInv():{Token t;}{	
	{jjtThis.operators = new Vector<Integer>();}

	<VAR> (<EQUAL>{jjtThis.operators.add(constants.EQUAL);}|<NOTEQUAL>{jjtThis.operators.add(constants.NOTEQUAL);}) (Set() | Range() ) | <PAR_OPEN> OrExpr() <PAR_CLOSE>
}


void Range():{}{
	{jjtThis.operators = new Vector<Integer>();}

	 (<REC_BRAC_O> {jjtThis.operators.add(constants.REC_BRAC_O);}| <REC_BRAC_C>{jjtThis.operators.add(constants.REC_BRAC_C);}) Aritm()","Aritm() (<REC_BRAC_O> | <REC_BRAC_C>)
}
void Set():{}{
	<PAR_SETO> Aritm() (","Aritm())* <PAR_SETC>
}


void Aritm():{}{
	(SumExpr())+ | <INF>
}
void SumExpr():{}{
	{jjtThis.operators = new Vector<Integer>();}

	multExpr() ( (<OP_SUM>{jjtThis.operators.add(constants.OP_SUM);}|<OP_DIFF>{jjtThis.operators.add(constants.OP_DIFF);})  multExpr() )*
}
void multExpr():{}{
	{jjtThis.operators = new Vector<Integer>();}

	atom() ( (	<OP_MUL>{jjtThis.operators.add(constants.OP_MUL);}	|	<OP_DIV>{jjtThis.operators.add(constants.OP_DIV);}	) atom() )*
}
void atom():{Token value;}{
	{jjtThis.operators = new Vector<Integer>();}

	(value=<NUM>{jjtThis.operators.add(constants.NUM);} | value=<VAR>{jjtThis.operators.add(constants.EQUAL);} ) {jjtThis.numVar =value.toString();}| <PAR_OPEN> SumExpr() <PAR_CLOSE>
}

