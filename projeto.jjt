options
{
    LOOKAHEAD=1;
    STATIC=false;
}

PARSER_BEGIN(InvariantParser)
/*Coisas p/ adicionar depois de compilar:
 SimpleNode:

  public Vector<Integer> operators;
  public String numVar;
  public boolean negative;
  public int getID() throws ParseException{
	return id;
  }


*/

package invariant.invariantEvaluator.Parser;
import java.util.HashMap;
import java.util.Vector;
import java.lang.Integer;
import java.lang.String;

public class InvariantParser
{
	Vector<String> vars;
	InvariantParserConstants constants;
	 SimpleNode getTree(String expr) throws ParseException{
            InputStream stream = new ByteArrayInputStream(expr.getBytes());
            ReInit(stream);
                return Inv_exp();
        }


}

PARSER_END(InvariantParser)


SKIP :
{
	" " |  "\r" | "\t"
}

TOKEN:
{
          <VAR		 : "$"(["0"-"9"])+ >
        | <VAR_TAG   : "var" >
        | <VAR_LOCAL : (["a"-"z"]|["A"-"Z"])+(["a"-"z"]|["A"-"Z"]|["1"-"9"])*>
      	| <NUM		 : (["0"-"9"])*(".")?(["0"-"9"])+ >
		| <OR		 : "||" >
		| <AND		 : "&&" >
		| <REC_BRAC_O: "["  >
		| <REC_BRAC_C: "]"  >
		| <PAR_OPEN  : "("  >
		| <PAR_CLOSE : ")"  >
		| <PAR_SETO  : "{"  >
		| <PAR_SETC  : "}"  >
		| <COMMA     : ","  >
		| <EQUAL 	 : "="  >
		| <NOTEQUAL  : "!=" >
		| <INF       : "@inf">
		| <OP_SUM    :  "+" >
		| <OP_DIFF   :  "-" >
		| <OP_MUL    :  "*" >
		| <OP_DIV    :  "/" >

}

SimpleNode Inv_exp():{}{
	( VarDecl() )*
	OrExpr() "\n"
	{return jjtThis;}
}
void OrExpr():{}{
	AndExpr() ( <OR> AndExpr() )*
}
void AndExpr():{}{
	atomInv() ( <AND> atomInv() )*
}
void atomInv():{Token value;}{
	{jjtThis.operators = new Vector<Integer>();}
	value=<VAR>{jjtThis.numVar =value.toString();} (<EQUAL>{jjtThis.operators.add(constants.EQUAL);}|<NOTEQUAL>{jjtThis.operators.add(constants.NOTEQUAL);}) (Set() | Range() ) | <PAR_OPEN> OrExpr() <PAR_CLOSE>
}


void Range():{}{
	{jjtThis.operators = new Vector<Integer>();}

	 (<REC_BRAC_O> {jjtThis.operators.add(constants.REC_BRAC_O);}| <REC_BRAC_C>{jjtThis.operators.add(constants.REC_BRAC_C);}) Aritm()","Aritm() (<REC_BRAC_O> {jjtThis.operators.add(constants.REC_BRAC_O);}| <REC_BRAC_C> {jjtThis.operators.add(constants.REC_BRAC_C);})
}
void Set():{}{
	<PAR_SETO> Aritm() (","Aritm())* <PAR_SETC>
}

void VarDecl():{}{
	<VAR_TAG> <VAR_LOCAL> <EQUAL> Aritm()
}






void Aritm():{}{
	SumExpr() | <INF>
}
void SumExpr():{}{
	{jjtThis.operators = new Vector<Integer>();}

	multExpr() ( (<OP_SUM>{jjtThis.operators.add(constants.OP_SUM);}|<OP_DIFF>{jjtThis.operators.add(constants.OP_DIFF);})  multExpr() )*
}
void multExpr():{}{
	{jjtThis.operators = new Vector<Integer>();}

	atom() ( (	<OP_MUL>{jjtThis.operators.add(constants.OP_MUL);}	|	<OP_DIV>{jjtThis.operators.add(constants.OP_DIV);}	) atom() )*
}
void atom():{Token value;}{



	{jjtThis.operators = new Vector<Integer>();jjtThis.negative=false;}
	[<OP_DIFF>{jjtThis.negative = true;}|<OP_SUM>]
	(
		(
			value=<NUM>{jjtThis.operators.add(constants.NUM);} |
			value=<VAR>{jjtThis.operators.add(constants.EQUAL);}
		) {jjtThis.numVar =value.toString();}	|
	 	<PAR_OPEN> SumExpr() <PAR_CLOSE>
	 )

}
